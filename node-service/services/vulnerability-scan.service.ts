// services/vulnerability-scan.service.ts
import Scan from '../models/Scan';
import { IScan, IDependency, IVulnerability } from '../types/models';
import osvService from './osv.service';
import { VulnerabilityScanOptions } from '../types/dto';
import rabbitMQService, { QUEUE_AI_VULNERABILITY_ANALYSIS } from './rabbitmq.service';
import { AIVulnerabilityMessage } from '../types/queue';
import logger from '../utils/logger';

/**
 * Service for scanning package vulnerabilities using OSV API
 */
export class VulnerabilityScanService {
  /**
   * Scan for vulnerabilities in dependencies from a completed dependency scan
   */
  public async scanVulnerabilities(
    scanId: string,
    options: VulnerabilityScanOptions = {}
  ): Promise<IScan | null> {
    try {
      // Get scan with dependencies
      const scan = await Scan.findById(scanId);

      if (!scan) {
        throw new Error('Scan not found');
      }

      if (scan.status !== 'completed') {
        throw new Error(
          'Cannot scan vulnerabilities for a scan that is not completed'
        );
      }

      // Update scan status to reflect vulnerability scanning is in progress
      scan.status = 'in-progress';
      await scan.save();

      // Clone dependencies for processing
      const dependencies = [...scan.dependencies];
      const processedDependencies: IDependency[] = [];

      // Filter dependencies if needed
      const dependenciesToScan = options.excludeDevDependencies
        ? dependencies.filter((dep) => dep.dependencyType !== 'devDependencies')
        : dependencies;

      if (options.quickScan) {
        // Process each dependency with quick scanning
        for (const dependency of dependenciesToScan) {
          // Get package name and cleaned version
          const packageName = dependency.packageName;
          const versionString = dependency.currentVersion.replace(
            /[^0-9.]/g,
            ''
          );

          // Quick scan using heuristics
          const quickResult = osvService.quickVulnerabilityCheck(
            packageName,
            versionString
          );

          let vulnerabilities: IVulnerability[] = [];

          if (quickResult.likelyVulnerable && quickResult.estimatedSeverity) {
            // Add a simulated vulnerability based on the quick check
            vulnerabilities = [
              {
                id: `QUICK-${packageName.toUpperCase()}-${Date.now()}`,
                severity: quickResult.estimatedSeverity,
                description: `Potential ${quickResult.estimatedSeverity} severity vulnerability in ${packageName}. This was detected using heuristic analysis and should be verified with a full scan.`,
                references: [
                  `https://osv.dev/vulnerability?ecosystem=npm&package=${packageName}`,
                ],
              },
            ];
          }

          // Update the dependency with vulnerability information
          const updatedDependency: IDependency = {
            ...dependency,
            vulnerabilities,
          };

          processedDependencies.push(updatedDependency);
        }
      } else {
        // Use batch processing for better performance with full scans
        const batchSize = options.batchSize || 10;

        for (let i = 0; i < dependenciesToScan.length; i += batchSize) {
          const batch = dependenciesToScan.slice(i, i + batchSize);

          // Prepare batch for OSV API
          const packageQueries = batch.map((dep) => ({
            name: dep.packageName,
            version: dep.currentVersion.replace(/[^0-9.]/g, ''),
            ecosystem: 'npm',
          }));

          // Run batch vulnerability check
          const batchResults = await osvService.batchCheckVulnerabilities(
            packageQueries
          );

          // Process batch results
          for (const dependency of batch) {
            const packageName = dependency.packageName;
            const versionString = dependency.currentVersion.replace(
              /[^0-9.]/g,
              ''
            );
            const key = `${packageName}@${versionString}`;

            let vulnerabilities = batchResults[key] || [];

            // Filter vulnerabilities if excludeHighRiskOnly is true
            if (options.excludeHighRiskOnly) {
              vulnerabilities = vulnerabilities.filter(
                (v) => v.severity === 'high' || v.severity === 'critical'
              );
            }

            // Update the dependency with vulnerability information
            const updatedDependency: IDependency = {
              ...dependency,
              vulnerabilities,
            };

            processedDependencies.push(updatedDependency);
          }
        }
      }

      // Include any dependencies that were skipped due to filtering
      if (options.excludeDevDependencies) {
        const devDependencies = dependencies.filter(
          (dep) => dep.dependencyType === 'devDependencies'
        );
        processedDependencies.push(...devDependencies);
      }

      // Update scan with processed dependencies and mark as completed
      scan.dependencies = processedDependencies;
      scan.status = 'completed';
      scan.completedAt = new Date();

      // Save and return the scan (pre-save hook will calculate counts)
      await scan.save();
      return scan;
    } catch (error) {
      console.error('Error scanning vulnerabilities:', error);

      // Update scan status to failed
      await Scan.findByIdAndUpdate(scanId, {
        status: 'failed',
        errorMessage:
          error instanceof Error
            ? `Vulnerability scan error: ${error.message}`
            : 'Unknown error during vulnerability scan',
        completedAt: new Date(),
      });

      throw error;
    }
  }

  /**
   * Get a summary of vulnerabilities for a scan
   */
  public async getVulnerabilitySummary(scanId: string): Promise<{
    total: number;
    high: number;
    medium: number;
    low: number;
    packagesAffected: number;
    highSeverityPackages: string[];
  }> {
    try {
      const scan = await Scan.findById(scanId);

      if (!scan) {
        throw new Error('Scan not found');
      }

      // Count packages with vulnerabilities
      const packagesWithVulnerabilities = scan.dependencies.filter(
        (dep) => dep.vulnerabilities && dep.vulnerabilities.length > 0
      );

      // Count by severity
      let highCount = 0;
      let mediumCount = 0;
      let lowCount = 0;

      // Get high severity package names
      const highSeverityPackages: string[] = [];

      for (const dep of scan.dependencies) {
        if (dep.vulnerabilities && dep.vulnerabilities.length > 0) {
          let hasHighSeverity = false;

          for (const vuln of dep.vulnerabilities) {
            if (vuln.severity === 'critical' || vuln.severity === 'high') {
              highCount++;
              hasHighSeverity = true;
            } else if (vuln.severity === 'medium') {
              mediumCount++;
            } else {
              lowCount++;
            }
          }

          if (hasHighSeverity) {
            highSeverityPackages.push(dep.packageName);
          }
        }
      }

      return {
        total: scan.vulnerabilityCount,
        high: highCount,
        medium: mediumCount,
        low: lowCount,
        packagesAffected: packagesWithVulnerabilities.length,
        highSeverityPackages,
      };
    } catch (error) {
      console.error('Error getting vulnerability summary:', error);
      throw error;
    }
  }

  /**
   * Get detailed vulnerability information for a specific package
   */
  public async getPackageVulnerabilities(
    scanId: string,
    packageName: string
  ): Promise<{
    packageName: string;
    currentVersion: string;
    latestVersion?: string;
    vulnerabilities: IVulnerability[];
  }> {
    try {
      const scan = await Scan.findById(scanId);

      if (!scan) {
        throw new Error('Scan not found');
      }

      const dependency = scan.dependencies.find(
        (dep) => dep.packageName === packageName
      );

      if (!dependency) {
        throw new Error(`Package ${packageName} not found in scan`);
      }

      return {
        packageName: dependency.packageName,
        currentVersion: dependency.currentVersion,
        latestVersion: dependency.latestVersion,
        vulnerabilities: dependency.vulnerabilities || [],
      };
    } catch (error) {
      console.error(
        `Error getting vulnerabilities for package ${packageName}:`,
        error
      );
      throw error;
    }
  }

  /**
   * Publish AI analysis jobs for all vulnerabilities in a scan
   * This is a fire-and-forget operation that doesn't block the vulnerability scan
   */
  public async publishAIAnalysisJobs(scan: IScan): Promise<void> {
    try {
      // Check if AI analysis is enabled
      const aiAnalysisEnabled = process.env.AI_ANALYSIS_ENABLED === 'true';

      if (!aiAnalysisEnabled) {
        logger.info('AI analysis is disabled. Skipping AI job publishing.');
        return;
      }

      let jobsPublished = 0;

      // Loop through all dependencies
      for (const dependency of scan.dependencies) {
        // Skip if no vulnerabilities
        if (!dependency.vulnerabilities || dependency.vulnerabilities.length === 0) {
          continue;
        }

        // Loop through all vulnerabilities for this dependency
        for (const vulnerability of dependency.vulnerabilities) {
          try {
            // Create AI vulnerability message
            const aiMessage: AIVulnerabilityMessage = {
              scanId: scan._id.toString(),
              userId: scan.userId.toString(),
              packageName: dependency.packageName,
              vulnerabilityId: vulnerability.id,
              osvData: {
                id: vulnerability.id,
                description: vulnerability.description,
                severity: vulnerability.severity,
                references: vulnerability.references || [],
                fixedIn: vulnerability.fixedIn,
              },
              packageContext: {
                currentVersion: dependency.currentVersion,
                latestVersion: dependency.latestVersion,
                dependencyType: dependency.dependencyType,
                ecosystem: 'npm', // Default to npm, can be made dynamic later
              },
            };

            // Publish to AI analysis queue (fire-and-forget)
            await rabbitMQService.sendToQueue(
              QUEUE_AI_VULNERABILITY_ANALYSIS,
              aiMessage
            );

            jobsPublished++;
          } catch (error) {
            // Log error but don't fail the entire process
            logger.error(
              `Failed to publish AI job for vulnerability ${vulnerability.id} in package ${dependency.packageName}:`,
              error
            );
          }
        }
      }

      logger.info(
        `Published ${jobsPublished} AI analysis jobs for scan ${scan._id}`
      );
    } catch (error) {
      // Log error but don't throw - AI processing is optional
      logger.error(
        `Error publishing AI analysis jobs for scan ${scan._id}:`,
        error
      );
    }
  }
}

// Export singleton instance
export const vulnerabilityScanService = new VulnerabilityScanService();

export default vulnerabilityScanService;
