// services/vulnerability-scan.service.ts
import Scan from '../models/Scan';
import { IScan, IDependency, IVulnerability } from '../types/models';
import osvService from './osv.service';

interface VulnerabilityScanOptions {
  quickScan?: boolean; // If true, use heuristics for a faster scan with less accuracy
  excludeDevDependencies?: boolean; // If true, don't scan dev dependencies
  excludeHighRiskOnly?: boolean; // If true, only flag high/critical vulnerabilities
  batchSize?: number; // Number of packages to check in a single batch request
}

/**
 * Service for scanning package vulnerabilities using OSV API
 */
export class VulnerabilityScanService {
  /**
   * Scan for vulnerabilities in dependencies from a completed dependency scan
   */
  public async scanVulnerabilities(
    scanId: string,
    options: VulnerabilityScanOptions = {}
  ): Promise<IScan | null> {
    try {
      // Get scan with dependencies
      const scan = await Scan.findById(scanId);
      
      if (!scan) {
        throw new Error('Scan not found');
      }
      
      if (scan.status !== 'completed') {
        throw new Error('Cannot scan vulnerabilities for a scan that is not completed');
      }
      
      // Update scan status to reflect vulnerability scanning is in progress
      scan.status = 'in-progress';
      await scan.save();
      
      // Clone dependencies for processing
      const dependencies = [...scan.dependencies];
      const processedDependencies: IDependency[] = [];
      
      // Filter dependencies if needed
      const dependenciesToScan = options.excludeDevDependencies
        ? dependencies.filter(dep => dep.dependencyType !== 'devDependencies')
        : dependencies;
      
      if (options.quickScan) {
        // Process each dependency with quick scanning
        for (const dependency of dependenciesToScan) {
          // Get package name and cleaned version
          const packageName = dependency.packageName;
          const versionString = dependency.currentVersion.replace(/[^0-9.]/g, '');
          
          // Quick scan using heuristics
          const quickResult = osvService.quickVulnerabilityCheck(
            packageName, 
            versionString
          );
          
          let vulnerabilities: IVulnerability[] = [];
          
          if (quickResult.likelyVulnerable && quickResult.estimatedSeverity) {
            // Add a simulated vulnerability based on the quick check
            vulnerabilities = [{
              id: `QUICK-${packageName.toUpperCase()}-${Date.now()}`,
              severity: quickResult.estimatedSeverity,
              description: `Potential ${quickResult.estimatedSeverity} severity vulnerability in ${packageName}. This was detected using heuristic analysis and should be verified with a full scan.`,
              references: [`https://osv.dev/vulnerability?ecosystem=npm&package=${packageName}`]
            }];
          }
          
          // Update the dependency with vulnerability information
          const updatedDependency: IDependency = {
            ...dependency,
            vulnerabilities
          };
          
          processedDependencies.push(updatedDependency);
        }
      } else {
        // Use batch processing for better performance with full scans
        const batchSize = options.batchSize || 10;
        
        for (let i = 0; i < dependenciesToScan.length; i += batchSize) {
          const batch = dependenciesToScan.slice(i, i + batchSize);
          
          // Prepare batch for OSV API
          const packageQueries = batch.map(dep => ({
            name: dep.packageName,
            version: dep.currentVersion.replace(/[^0-9.]/g, ''),
            ecosystem: 'npm'
          }));
          
          // Run batch vulnerability check
          const batchResults = await osvService.batchCheckVulnerabilities(packageQueries);
          
          // Process batch results
          for (const dependency of batch) {
            const packageName = dependency.packageName;
            const versionString = dependency.currentVersion.replace(/[^0-9.]/g, '');
            const key = `${packageName}@${versionString}`;
            
            let vulnerabilities = batchResults[key] || [];
            
            // Filter vulnerabilities if excludeHighRiskOnly is true
            if (options.excludeHighRiskOnly) {
              vulnerabilities = vulnerabilities.filter(
                v => v.severity === 'high' || v.severity === 'critical'
              );
            }
            
            // Update the dependency with vulnerability information
            const updatedDependency: IDependency = {
              ...dependency,
              vulnerabilities
            };
            
            processedDependencies.push(updatedDependency);
          }
        }
      }
      
      // Include any dependencies that were skipped due to filtering
      if (options.excludeDevDependencies) {
        const devDependencies = dependencies.filter(dep => dep.dependencyType === 'devDependencies');
        processedDependencies.push(...devDependencies);
      }
      
      // Update scan with processed dependencies and mark as completed
      scan.dependencies = processedDependencies;
      scan.status = 'completed';
      scan.completedAt = new Date();
      
      // Save and return the scan (pre-save hook will calculate counts)
      await scan.save();
      return scan;
    } catch (error) {
      console.error('Error scanning vulnerabilities:', error);
      
      // Update scan status to failed
      await Scan.findByIdAndUpdate(scanId, {
        status: 'failed',
        errorMessage: error instanceof Error 
          ? `Vulnerability scan error: ${error.message}` 
          : 'Unknown error during vulnerability scan',
        completedAt: new Date()
      });
      
      throw error;
    }
  }
  
  /**
   * Get a summary of vulnerabilities for a scan
   */
  public async getVulnerabilitySummary(scanId: string): Promise<{
    total: number;
    high: number;
    medium: number;
    low: number;
    packagesAffected: number;
    highSeverityPackages: string[];
  }> {
    try {
      const scan = await Scan.findById(scanId);
      
      if (!scan) {
        throw new Error('Scan not found');
      }
      
      // Count packages with vulnerabilities
      const packagesWithVulnerabilities = scan.dependencies.filter(
        dep => dep.vulnerabilities && dep.vulnerabilities.length > 0
      );
      
      // Count by severity
      let highCount = 0;
      let mediumCount = 0; 
      let lowCount = 0;
      
      // Get high severity package names
      const highSeverityPackages: string[] = [];
      
      for (const dep of scan.dependencies) {
        if (dep.vulnerabilities && dep.vulnerabilities.length > 0) {
          let hasHighSeverity = false;
          
          for (const vuln of dep.vulnerabilities) {
            if (vuln.severity === 'critical' || vuln.severity === 'high') {
              highCount++;
              hasHighSeverity = true;
            } else if (vuln.severity === 'medium') {
              mediumCount++;
            } else {
              lowCount++;
            }
          }
          
          if (hasHighSeverity) {
            highSeverityPackages.push(dep.packageName);
          }
        }
      }
      
      return {
        total: scan.vulnerabilityCount,
        high: highCount,
        medium: mediumCount,
        low: lowCount,
        packagesAffected: packagesWithVulnerabilities.length,
        highSeverityPackages
      };
    } catch (error) {
      console.error('Error getting vulnerability summary:', error);
      throw error;
    }
  }
  
  /**
   * Get detailed vulnerability information for a specific package
   */
  public async getPackageVulnerabilities(
    scanId: string,
    packageName: string
  ): Promise<{
    packageName: string;
    currentVersion: string;
    latestVersion?: string;
    vulnerabilities: IVulnerability[];
  }> {
    try {
      const scan = await Scan.findById(scanId);
      
      if (!scan) {
        throw new Error('Scan not found');
      }
      
      const dependency = scan.dependencies.find(dep => dep.packageName === packageName);
      
      if (!dependency) {
        throw new Error(`Package ${packageName} not found in scan`);
      }
      
      return {
        packageName: dependency.packageName,
        currentVersion: dependency.currentVersion,
        latestVersion: dependency.latestVersion,
        vulnerabilities: dependency.vulnerabilities || []
      };
    } catch (error) {
      console.error(`Error getting vulnerabilities for package ${packageName}:`, error);
      throw error;
    }
  }
}

// Export singleton instance
export const vulnerabilityScanService = new VulnerabilityScanService();

export default vulnerabilityScanService;