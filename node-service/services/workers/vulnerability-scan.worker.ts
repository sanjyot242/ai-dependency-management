// workers/vulnerability-scan.worker.ts
import logger from '../../utils/logger';
import rabbitMQService, {
  QUEUE_VULNERABILITY_SCAN,
} from '../../services/rabbitmq.service';
import { VulnerabilityScanMessage } from '../../types/queue';
import vulnerabilityScanService from '../../services/vulnerability-scan.service';
import Scan from '../../models/Scan';
import scanProcessManager from '../../services/scan-process-manager.service';

class VulnerabilityScanWorker {
  /**
   * Initialize the worker to consume jobs from the vulnerability scan queue
   */
  public async start(): Promise<void> {
    try {
      logger.info('Starting Vulnerability Scan Worker');

      // Start consuming from vulnerability scan queue
      await rabbitMQService.consumeQueue<VulnerabilityScanMessage>(
        QUEUE_VULNERABILITY_SCAN,
        this.processVulnerabilityScan.bind(this)
      );

      logger.info('Vulnerability Scan Worker is running');
    } catch (error) {
      logger.error('Error starting Vulnerability Scan Worker:', error);
      throw error;
    }
  }

  /**
   * Process a vulnerability scan job
   */
  private async processVulnerabilityScan(
    message: VulnerabilityScanMessage
  ): Promise<void> {
    const { scanId, userId, options } = message;
    logger.info(
      `Processing vulnerability scan job: scanId=${scanId}, userId=${userId}`
    );

    try {
      // Verify the scan exists and belongs to user
      const scan = await Scan.findOne({ _id: scanId, userId });
      if (!scan) {
        throw new Error('Scan not found or not authorized');
      }

      // Make sure we're in the right state
      if (scan.state !== 'vulnerability-scanning') {
        logger.warn(
          `Scan ${scanId} is not in vulnerability-scanning state. Current state: ${scan.state}`
        );
        // We'll continue anyway since it may have been queued by the process manager
      }

      // Perform vulnerability scan
      const updatedScan = await vulnerabilityScanService.scanVulnerabilities(
        scanId,
        options || {}
      );

      if (!updatedScan) {
        throw new Error('Vulnerability scan failed to complete');
      }

      // Publish AI analysis jobs for all vulnerabilities (fire-and-forget)
      await vulnerabilityScanService.publishAIAnalysisJobs(updatedScan);

      // Notify process manager of completion
      await scanProcessManager.handleVulnerabilityScanComplete(
        scanId,
        updatedScan.status as 'completed' | 'failed',
        {
          vulnerabilityCount: updatedScan.vulnerabilityCount,
          highSeverityCount: updatedScan.highSeverityCount,
          errorMessage: updatedScan.errorMessage,
        }
      );

      logger.info(
        `Vulnerability scan completed successfully: scanId=${scanId}`
      );

      // Log high severity findings
      if (updatedScan.highSeverityCount > 0) {
        logger.warn(
          `Scan completed with ${updatedScan.highSeverityCount} high/critical severity ` +
            `vulnerabilities (out of ${updatedScan.vulnerabilityCount} total) for scanId=${scanId}`
        );
      }
    } catch (error) {
      logger.error(
        `Error processing vulnerability scan job for scanId=${scanId}:`,
        error
      );

      const errorMessage =
        error instanceof Error
          ? `Vulnerability scan error: ${error.message}`
          : 'Unknown error during vulnerability scan';

      // Notify process manager of failure
      await scanProcessManager.handleScanFailure(scanId, errorMessage);
    }
  }
}

export const vulnerabilityScanWorker = new VulnerabilityScanWorker();

// Start worker if executed directly
if (require.main === module) {
  vulnerabilityScanWorker.start().catch((err) => {
    logger.error('Failed to start vulnerability scan worker:', err);
    process.exit(1);
  });
}

export default vulnerabilityScanWorker;
